#!/usr/bin/env python3

import os
import sys
import time
import shutil
import argparse
import subprocess

try:
  import serial
except ImportError:
  pass

imports = dir()

# Checks for ANSI escape codes support
def formatter(func):
  def wrapper(text):
    posix_support = os.name == 'posix' and hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
    win_support = os.name == 'nt' and 'ANSICON' in os.environ
    if posix_support or win_support:
      return func(text)
    return text

  return wrapper

class CLI:
  def __init__(self, verbosity=0):
    self.verbosity = verbosity
    self.footprint = CLI.bold(os.path.basename(__file__)) + ':'

  @staticmethod
  @formatter
  def bold(text):
    return '{}{}{}'.format('\033[1m', text, '\033[0m')

  @staticmethod
  @formatter
  def red(text):
    return '{}{}{}'.format('\033[31m', text, '\033[0m')

  @staticmethod
  @formatter
  def green(text):
    return '{}{}{}'.format('\033[32m', text, '\033[0m')

  def print(self, text, verbosity=0, success=False, error=False):
    if self.verbosity < verbosity:
      return

    if error:
      sys.stderr.write('{} {}\n'.format(self.footprint, CLI.bold(CLI.red(text))))
    elif success:
      print(self.footprint, CLI.bold(CLI.green(text)))
    else:
      print(self.footprint, text)

  def call(self, arglist, exit_on_error=True, success_message=None):
    kwargs = {}
    if self.verbosity < 1:
      kwargs = {'stdout': subprocess.DEVNULL, 'stderr': subprocess.DEVNULL}

    try:
      if subprocess.call(arglist, **kwargs):
        self.print('Failure while executing {}.\n'.format(arglist[0]), error=True)
        if exit_on_error:
          sys.exit(1)
      elif success_message is not None:
        cli.print(success_message, success=True, verbosity=2)
    except FileNotFoundError:
      cli.print('Command not found: {}.'.format(arglist[0]), error=True)
      cli.print('Make sure you\'ve included all the necessary executables in your PATH')
      cli.print('see README.md for more information')
      sys.exit(1)
    except KeyboardInterrupt:
      cli.print('{} interrupted.'.format(arglist[0]), error=True)
      sys.exit(1)

class Project:
  standard_makefile = 'Makefile'
  cpp_makefile = 'Makefile_cpp.mk'

  def __init__(self, dir_, cpp=False):
    self.start = None
    self.dir = os.path.abspath(dir_)
    self.cpp = cpp
    self.build_dir = 'build'

    self.bin = self.path(os.path.join(self.build_dir, self.name() + '.bin'))
    self.elf = self.path(os.path.join(self.build_dir, self.name() + '.elf'))
    self.hex = self.path(os.path.join(self.build_dir, self.name() + '.hex'))

    os.chdir(self.dir)

  def __enter__(self):
    self.start = time.time()
    return self

  def __exit__(self, ex_type, ex_val, traceback):
    took = time.time() - self.start
    if took > 0.01:
      cli.print('Done in {0:0.2f} seconds.'.format(time.time() - self.start), verbosity=2)

  def path(self, file_=''):
    return os.path.join(self.dir, file_)

  def name(self):
    return os.path.basename(self.dir)

  def compile(self):
    success_msg = 'Successfuly compiled firmware'
    if self.cpp:
      cli.print('Compiling for C++', verbosity=1)
      self.generate_cpp_makefile()
      cli.call(['make', '-f', self.path(Project.cpp_makefile)],
        success_message=success_msg)
    else:
      cli.print('Compiling for C', verbosity=1)
      cli.call(['make', '-f', self.path(Project.standard_makefile)],
        success_message=success_msg)

  def generate_cpp_makefile(self):
    with open(self.path(Project.standard_makefile), 'r') as f:
      data = f.read()

    data = data.replace('gcc', 'g++')
    splitdata = data.splitlines()

    for i, line in enumerate(splitdata):
      if 'LDFLAGS =' in line:
        splitdata.insert(i+1, 'LDFLAGS += -specs=nosys.specs')

      if 'CFLAGS =' in line:
        splitdata.insert(i+1, 'CFLAGS += -std=c++14')

    with open(self.path(Project.cpp_makefile), 'w') as f:
      f.write('\n'.join(splitdata))

  def upload(self):
    cli.call(['st-flash', 'write', self.bin, '0x8000000'],
      success_message='Successfully uploaded firmware.')

  def debug(self):
    cli.print('Starting GDB server', verbosity=1)

    kwargs = {}
    if cli.verbosity < 3:
      kwargs = {'stdout': subprocess.DEVNULL, 'stderr': subprocess.DEVNULL}

    gdb_server = subprocess.Popen(['st-util'], **kwargs)

    time.sleep(0.1)
    if gdb_server.poll():
      cli.print('Failed to start GDB server.', error=True)
    else:
      cli.print('Successfully started GDB server.', verbosity=2)

    try:
      cli.call(['arm-none-eabi-gdb', self.elf, '-ex', 'tar extended-remote :4242'])
    except KeyboardInterrupt:
      pass
    finally:
      cli.print('Closing GDB server.', verbosity=1)
      gdb_server.kill()
      cli.print('GDB server killed.', verbosity=2)

  def size(self):
    for file_ in [self.bin, self.elf, self.hex]:
      with open(file_, 'r') as f:
        f.seek(0, 2)
        cli.print('{}: {} B'.format(os.path.basename(file_), f.tell()))

  def clean(self):
    cli.print('Cleaning build directory.', verbosity=1)

    try:
      shutil.rmtree(self.build_dir)
      cli.print('Successfully cleaned build directory.', verbosity=2, success=True)
    except FileNotFoundError:
      cli.print('Build directory doesn\'t exist', error=True)


class STLink:
  @staticmethod
  def probe():
    cli.call(['st-info', '--probe'])

  @staticmethod
  def reset():
    cli.call(['st-flash', 'reset'])

  @staticmethod
  def monitor(port):
    if 'serial' in imports:
      s = None
      try:
        s = serial.Serial(port=port)
      except serial.serialutil.SerialException:
        cli.print('Serial port failure: {}'.format(port), error=True)

      if s is None:
        sys.exit(1)

      try:
        while True:
          print(s.read().decode('utf8'), end='')
      except KeyboardInterrupt:
        sys.exit()

    # If pyserial not found but OS is POSIX then just call cat
    elif os.name == 'posix':
      cli.call(['cat', port])
    else:
      cli.print('`serial` module not installed. Try installing `pyserial` with pip,', error=True)
      sys.exit(1)

if __name__ == '__main__':
  parser = argparse.ArgumentParser(
    description='Upload, debug and compile STM32CubeMX Makefile projects')

  common_ops = parser.add_argument_group(title='Common operations')
  common_ops.add_argument('-u', '--upload', action='store_true')
  common_ops.add_argument('-d', '--debug', action='store_true', help='Start GDB session')
  common_ops.add_argument('-v', '--verbosity', type=int, default=2, metavar='V',
    help='Verbosity level from -1 (completely silent) to 2 (fully verbose, default)')

  project_ops = parser.add_argument_group(title='Project operations')
  project_ops.add_argument('-c', '--compile', action='store_true',
    help='Call make with appropriate Makefile')
  project_ops.add_argument('-p', '--project-dir', default=os.getcwd(),
    metavar='DIR', type=str, help='Defaults to current dir')
  project_ops.add_argument('-s', '--size', action='store_true', help='Print size of built binaries')
  project_ops.add_argument('-x', '--cpp', help='Use C++ rather than C', action='store_true')
  project_ops.add_argument('-z', '--clean', action='store_true',
    help='Clean (remove) build directory')

  stlink_ops = parser.add_argument_group(title='ST-Link operations')
  stlink_ops.add_argument('-i', '--probe', action='store_true',
    help='Print ST-Link connection information')
  stlink_ops.add_argument('-m', '--monitor', type=str, metavar='PORT', help='Serial monitor')
  stlink_ops.add_argument('-r', '--reset', action='store_true', help='Reset the microcontroller')

  if len(sys.argv) < 2:
    parser.print_help()
    sys.exit()
    
  args = parser.parse_args()

  cli = CLI(verbosity=args.verbosity)

  if args.reset:
    STLink.reset()

  if args.probe:
    STLink.probe()

  if args.monitor:
    STLink.monitor(args.monitor)

  with Project(args.project_dir, cpp=args.cpp) as project:
    if args.size:
      project.size()

    if args.clean:
      project.clean()

    if args.compile:
      project.compile()

    if args.upload:
      project.upload()

    if args.debug:
      project.debug()
