#!/usr/bin/env python3

import os
import sys
import time
import shutil
import argparse
import subprocess

def formatter(func):
  def wrapper(text):
    if os.name == 'posix':
      return func(text)
    return text

  return wrapper

class CLI:
  def __init__(self, verbosity_level=0):
    self.verbosity_level = verbosity_level

  @staticmethod
  @formatter
  def bold(text):
    return '{}{}{}'.format('\033[1m', text, '\033[0m')

  @staticmethod
  @formatter
  def red(text):
    return '{}{}{}'.format('\033[31m', text, '\033[0m')

  @staticmethod
  @formatter
  def green(text):
    return '{}{}{}'.format('\033[32m', text, '\033[0m')

  def print(self, text, verbosity_level=0, success=False, error=False):
    if self.verbosity_level < verbosity_level:
      return

    if error:
      sys.stderr.write(CLI.bold('mkstm32: ' + CLI.red(text)) + '\n')
    elif success:
      print(CLI.bold('mkstm32:'), CLI.green(text))
    else:
      print(CLI.bold('mkstm32:'), text)

  def call(self, arglist, exit_on_error=True, success_message=None):
    kwargs = {}
    if self.verbosity_level == 0:
      kwargs = {'stdout': subprocess.DEVNULL, 'stderr': subprocess.DEVNULL}

    try:
      if subprocess.call(arglist, **kwargs):
        self.print('Failure while executing {}.\n'.format(arglist[0]), error=True)
        if exit_on_error:
          sys.exit(1)
      elif success_message is not None:
        cli.print(success_message, success=True)
    except FileNotFoundError:
      cli.print('Command not found: {}.'.format(arglist[0]), error=True)
      cli.print('Make sure you\'ve included all the necessary executables in your PATH')
      cli.print('see README.md for more information')
      sys.exit(1)

class Project:
  standard_makefile = 'Makefile'
  cpp_makefile = 'Makefile_cpp.mk'

  def __init__(self, dir_, cpp=False):
    self.dir = os.path.abspath(dir_)
    self.cpp = cpp
    self.build_dir = 'build'

    self.bin = self.path(os.path.join(self.build_dir, self.name() + '.bin'))
    self.elf = self.path(os.path.join(self.build_dir, self.name() + '.elf'))
    self.hex = self.path(os.path.join(self.build_dir, self.name() + '.hex'))

    self.binaries = [self.bin, self.elf, self.hex]

    os.chdir(self.dir)

  def path(self, file_=''):
    return os.path.join(self.dir, file_)

  def name(self):
    return os.path.basename(self.dir)

  def __enter__(self):
    return self

  def __exit__(self, ex_type, ex_val, traceback):
    pass

  def compile(self):
    success_msg = 'Successfuly compiled firmware'
    if self.cpp:
      cli.print('Compiling for C++', verbosity_level=2)
      self.generate_cpp_makefile()
      cli.call(['make', '-f', self.path(Project.cpp_makefile)],
        success_message=success_msg)
    else:
      cli.print('Compiling for C', verbosity_level=2)
      cli.call(['make', '-f', self.path(Project.standard_makefile)],
        success_message=success_msg)

  def generate_cpp_makefile(self):
    with open(self.path(Project.standard_makefile), 'r') as f:
      data = f.read()

    data = data.replace('gcc', 'g++')
    splitdata = data.splitlines()

    for i, line in enumerate(splitdata):
      if 'LDFLAGS =' in line:
        splitdata.insert(i+1, 'LDFLAGS += -specs=nosys.specs')

      if 'CFLAGS =' in line:
        splitdata.insert(i+1, 'CFLAGS += -std=c++14')

    with open(self.path(Project.cpp_makefile), 'w') as f:
      f.write('\n'.join(splitdata))

  def upload(self):
    cli.call(['st-flash', 'write', self.bin, '0x8000000'],
      success_message='Successfully uploaded firmware.')

  def debug(self):
    cli.print('Starting GDB server', verbosity_level=2)

    kwargs = {}
    if cli.verbosity_level < 3:
      kwargs = {'stdout': subprocess.DEVNULL, 'stderr': subprocess.DEVNULL}

    gdb_server = subprocess.Popen(['st-util'], **kwargs)

    time.sleep(0.1)
    if gdb_server.poll():
      cli.print('Failed to start GDB server.', error=True)
    else:
      cli.print('Successfully started GDB server.', verbosity_level=2)

    try:
      cli.call(['arm-none-eabi-gdb', self.elf, '-ex', 'tar extended-remote :4242'])
    except KeyboardInterrupt:
      pass
    finally:
      cli.print('Closing GDB server.', verbosity_level=2)
      gdb_server.kill()
      cli.print('Done.', verbosity_level=2)

  def size(self):
    for file_ in self.binaries:
      with open(file_, 'r') as f:
        f.seek(0, 2)
        cli.print('  {}: {} B'.format(os.path.basename(file_), f.tell()))

  def clean(self):
    cli.print('Cleaning build directory.', verbosity_level=2)

    try:
      shutil.rmtree(self.build_dir)
      cli.print('Successfully cleaned build directory.', verbosity_level=1, success=True)
    except FileNotFoundError:
      cli.print('Build directory doesn\'t exist', error=True)


class STLink:
  @staticmethod
  def probe():
    cli.call(['st-info', '--probe'])

  @staticmethod
  def reset():
    cli.call(['st-flash', 'reset'])


if __name__ == '__main__':
  start = time.time()

  parser = argparse.ArgumentParser(
    description='Upload, debug and compile STM32CubeMX Makefile projects')

  common_ops = parser.add_argument_group(title='Common operations')
  common_ops.add_argument('-u', '--upload', action='store_true')
  common_ops.add_argument('-d', '--debug', action='store_true', help='Start GDB session')
  common_ops.add_argument('-v', '--verbosity', help='Verbosity level (0-3)', type=int, default=2)

  project_ops = parser.add_argument_group(title='Project operations')
  project_ops.add_argument('-c', '--compile', action='store_true',
    help='Call make with appropriate Makefile')
  project_ops.add_argument('-p', '--project-dir', default=os.getcwd(),
    metavar='DIR', type=str, help='Defaults to current dir')
  project_ops.add_argument('-s', '--size', action='store_true', help='Print size of built binaries')
  project_ops.add_argument('-x', '--cpp', help='Use C++ rather than C', action='store_true')
  project_ops.add_argument('-z', '--clean', action='store_true',
    help='Clean (remove) build directory')

  stlink_ops = parser.add_argument_group(title='ST-Link operations')
  stlink_ops.add_argument('-i', '--probe', action='store_true',
    help='Print ST-Link connection information')
  stlink_ops.add_argument('-r', '--reset', action='store_true', help='Reset the microcontroller')

  args = parser.parse_args()

  cli = CLI(verbosity_level=args.verbosity)

  if len(sys.argv) < 2:
    parser.print_help()
    sys.exit()

  if args.reset:
    STLink.reset()

  if args.probe:
    STLink.probe()

  with Project(args.project_dir, cpp=args.cpp) as project:
    if args.size:
      project.size()
      sys.exit()

    if args.clean:
      project.clean()

    if args.compile:
      project.compile()

    if args.upload:
      project.upload()

    if args.debug:
      project.debug()

    end = time.time() - start
    cli.print('Done in {0:0.2f} seconds.'.format(end))
