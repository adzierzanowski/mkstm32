#!/usr/bin/env python3

import os
import sys
import time
import shutil
import argparse
import subprocess

cpp_makefile = 'Makefile_cpp.mk'
gcc_path = None

# CLI text formatting

def cli_format(func):
  def wrapper(text):
    if os.name == 'posix':
      return func(text)
    else:
      return text
  return wrapper

@cli_format
def bold(text):
  return '\033[1m{}\033[0m'.format(text)

@cli_format
def green(text):
  return '\033[32m{}\033[0m'.format(text)

@cli_format
def red(text):
  return '\033[31m{}\033[0m'.format(text)

def print_message(message, error=False, success=False, verbose=False):
  if success:
    message = '{}'.format(bold(green(message)))

  if error:
    sys.stderr.write(bold(prog_name))
    sys.stderr.write(': {}\n'.format(bold(red(message))))
    sys.exit(1)

  elif ((verbose and not args.silent) or not verbose):
    print('{}: {}'.format(bold(prog_name), message))

# Tries to call another program and prints messages
def call_executable(cmd, error_message):
  try:
    if (subprocess.call(cmd)):
      print_message(error_message, error=True)
  except FileNotFoundError:
    print_message('Failed to execute {}. Make sure you\'ve included it in your PATH.'.format(cmd[0]), error=True)

# Returns size of a file
def fsize(fname):
  with open(fname) as f:
    f.seek(0, 2)
    return f.tell()

# Generates Makefile for C++ based on the makefile generated by Cube
def generate_cpp_makefile():
  print_message('Generating C++ Makefile.', verbose=True)

  with open(args.makefile, 'r') as f:
    data = f.read()

  data = data.replace('gcc', 'g++')

  splitdata = data.splitlines()
  for i, line in enumerate(splitdata):
    if 'LDFLAGS =' in line:
      splitdata.insert(i + 1, 'LDFLAGS += -specs=nosys.specs')

  with open(cpp_makefile, 'w') as f:
    f.write('\n'.join(splitdata))


# Execution time is measured for some actions
start = time.time()

# This executable name
prog_name = os.path.basename(sys.argv[0])

parser = argparse.ArgumentParser(description='Build, upload and debug '
                                 'an STM32Cube Makefile project')

common = parser.add_argument_group(title='Most useful switches')
rare = parser.add_argument_group(title='Some not so useful switches')

common.add_argument('-c', '--compile', action='store_true')
common.add_argument('-d', '--debug', action='store_true', help='Start a debugging session')
common.add_argument('-i', '--info', action='store_true', help='Display ST-Link information')
common.add_argument('-r', '--reset', action='store_true',help='Reset the mcu')
common.add_argument('-s', '--size', action='store_true', help='See the size of the binaries')
common.add_argument('-u', '--upload', action='store_true')
common.add_argument('-t', '--silent', action='store_true', help='Silent mode')
common.add_argument('-x', '--c-plus-plus', action='store_true', help='Build with g++')

rare.add_argument('-b', '--binary', type=str)
rare.add_argument('-g', '--gcc-path', type=str)
rare.add_argument('-m', '--makefile', type=str, default='Makefile', help='Makefile generated with STM32Cube')
rare.add_argument('-p', '--project-directory', type=str, default=os.getcwd())
rare.add_argument('--flash-address', type=str, default='0x8000000')

args = parser.parse_args()

if args.project_directory != os.getcwd():
  args.makefile = os.path.join(args.project_directory, args.makefile)
  os.chdir(args.project_directory)

if args.gcc_path:
  gcc_path = args.gcc_path
elif 'GCC_PATH' in os.environ.keys():
  gcc_path = os.getenv('GCC_PATH')

if gcc_path:
  os.putenv('GCC_PATH', gcc_path)

if args.binary:
  bin_file = args.binary
  elf_file = bin_file
else:
  filename_base = os.path.basename(args.project_directory)
  bin_file = os.path.join(args.project_directory, 'build',
                             filename_base + '.bin')
  elf_file = os.path.join(args.project_directory, 'build',
                          filename_base + '.elf')
  hex_file = os.path.join(args.project_directory, 'build',
                          filename_base + '.hex')


if args.reset:
  call_executable(['st-flash', 'reset'], 'Failed to reset the MCU.')
  sys.exit()

if args.info:
  call_executable(['st-info', '--probe'], 'Failed to probe the MCU.')
  sys.exit()

if args.size:
  bin_size = fsize(bin_file)
  elf_size = fsize(elf_file)
  hex_size = fsize(hex_file)
  
  bin_file = os.path.basename(bin_file)
  elf_file = os.path.basename(elf_file)
  hex_file = os.path.basename(hex_file)

  print_message('\n\t{}: {} B\n\t{}: {} B\n\t{}: {} B'.format(bin_file,
                                                              bin_size,
                                                              elf_file,
                                                              elf_size,
                                                              hex_file,
                                                              hex_size))
  sys.exit()

if not any([args.compile, args.upload, args.debug]):
  parser.print_help()
  sys.exit(1)

if args.debug:
  print_message('Starting GDB server.', verbose=True)
  gdb_server = subprocess.Popen(['st-util'],
                                stdout=subprocess.DEVNULL,
                                stderr=subprocess.DEVNULL)

  time.sleep(0.1)

  if gdb_server.poll():
    print_message('Failed to start a GDB server.', error=True)
  else:
    print_message('Successfully started GDB server.', verbose=True)

  try:
    subprocess.call(['arm-none-eabi-gdb', elf_file])
  except KeyboardInterrupt:
    pass

  print_message('Closing the GDB server.', verbose=True)
  gdb_server.kill()
  print_message('Done.', verbose=True)
  sys.exit()

if args.compile:
  if args.c_plus_plus:
    print_message('Compiling for C++.', verbose=True)
    generate_cpp_makefile()
    makefile = os.path.join(args.project_directory, cpp_makefile)
  else:
    print_message('Compiling for C.', verbose=True)
    makefile = args.makefile

  print_message('Cleaning build directory.', verbose=True)
  cleaning_fail_msg = 'Failed to clean build directory.'
  if os.name == 'posix':
    call_executable(['make', '-f', args.makefile, 'clean'],
                    cleaning_fail_msg)
  elif os.name == 'nt':
    shutil.rmtree(os.path.join(args.project_directory, 'build'))

  print_message('Calling make.', verbose=True)
  call_executable(['make', '-f', makefile], 'Failed to successfully execute make.')

  print_message('Successfully compiled firmware.',
                verbose=True, success=True)

if args.upload:
  filename = bold(os.path.basename(bin_file))
  print_message('Uploading {} to the microcontroller.'.format(filename, verbose=True))

  if subprocess.call(['st-flash', 'write', bin_file, '0x8000000']):
    print_message('Failed to flash the MCU.', error=True)
  else:
    print_message('Successfully uploaded firmware.',
                  verbose=True, success=True)

time_elapsed = '{0:0.2f}'.format(time.time() - start)
print_message('Done in {} seconds.'.format(bold(time_elapsed)),
              verbose=True)
